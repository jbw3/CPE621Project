#include "amdessServiceLib.sblib"
#include "ad7746.sb"

///////////////////////////////
// program settings
#define ADVERT_TMOUT_SEC 120
///////////////////////////////

///////////////////////////////
// gap settings
///////////////////////////////
#define DEV_NAME "AMDeSS Sensor"
#define NAME_IS_WR 0                // name is writable
#define APPEAR 0                    // unknown
#define MIN_CON_INT 500000            // min connection interval (microseconds)
#define MAX_CON_INT 1000000         // max connection interval (microseconds)
#define SUPRV_TO 4000000
#define SLAVE_LTCY 0
///////////////////////////////

///////////////////////////////
// global program variables
///////////////////////////////
dim res             // result of operations
dim uartRes         // result of uart commands
dim unknownCmd      // flags an unknown command
dim endFuncVal      // variable for endfunc
dim conn            // connection handle
dim r0              // "register 0" (just a variable that can be used local to
                    // any function, like a GP register)

// ble handles
dim hAmdessSvc       // AMDeSS service handle
dim hArmStateChar       // ARM STATE characteristic handle
dim hAlarmStateChar     // ALARM STATE characteristic handle

// program state variables
dim armState            // holds value of arm state
dim armStateCCCD        // holds value of arm state CCCD
dim notifyArmState      // caches the notify bit from CCCD so it is only extracted
                        // from CCCD when it actually changes
dim alarmState          // holds value of alarm state
dim alarmStateCCCD      // holds value of alarm state CCCD
dim notifyAlarmState    // caches the notify bit from CCCD so it is only extracted
                        // from CCCD when it actually changes

// uart vars
dim uartRxStr$
dim termCmd$
dim armCmd$, disarmCmd$
dim alarmOnCmd$, alarmOffCmd$
dim uartStrLen
///////////////////////////////

termCmd$ = "end\r"  // ends execution
armCmd$ = "arm\r"   // arms device
disarmCmd$ = "disarm\r"     // disarms device
alarmOnCmd$ = "alarm on\r"        // triggers an alarm condition (if armed)
alarmOffCmd$ = "alarm off\r"   // turns off alarm (if alarming)

////
//// Handle BLE Advertizing Timeout
////
function HandleBleAdvTimeout()
    print "\nAdvert timed out."
endfunc 0

////
//// Configure BLE GAP service
////
sub ConfigureGAP()
    res = BleGapSvcInit(DEV_NAME, NAME_IS_WR, APPEAR, MIN_CON_INT, MAX_CON_INT, SUPRV_TO, SLAVE_LTCY)
    if (res == 0) then
        print "\nGAP service initialized successfully!"
    else
        print "\nBleGapSvcInit() failed with a result of ", res
    endif
endsub

////
//// StartBle()
////
sub StartBle()

    dim peerAdr$
    dim advertInterval_ms : advertInterval_ms = 1000    // advertise every second
    dim advertTimeout_ms : advertTimeout_ms = ADVERT_TMOUT_SEC * 1000

    // configure the GAP service
    print "\nConfiguring GAP..."
    ConfigureGAP()
    print "\nCurrent device name: ", BleGetDeviceName$()

    // configure Amdess service
    print "\nConfiguring AMDeSS service..."
    CreateAmdessService(hAmdessSvc, hArmStateChar, hAlarmStateChar)

    if BleAdvertStart(BLE_ADV_INDIRECT, peerAdr$, advertInterval_ms, advertTimeout_ms, BLE_FP_DISABLE_WHITELIST) == 0 then
        print "\nStarted advertising..."
    else
        print "\nUnable to start advertising!"
    endif

endsub

////
//// UpdateIsSampling()
////
sub UpdateIsSampling(byRef armStateInt, byRef alarmStateInt)

    // only update whether or not we're sampling if we're not in the middle of calibrating
    if isCalibrating != 1 then
        // we sample if we are either (armed AND not alarming) OR if the Notify CCCD bit is set for capacitance debug data
        if armStateInt == 1 && alarmStateInt == 0 then
            StartSamplingAD7746(r0)
        else
            StopSamplingAD7746()
        endif
    endif

endsub

////
//// ReadArmState()
////
function ReadArmState(byRef armStateInt)
    res = ReadU8CharValue(hArmStateChar, armStateInt)
    if res != 0 then
        print "\nUnable to read ARM STATE", res
    endif
endfunc res

////
//// ReadAlarmState()
////
function ReadAlarmState(byRef alarmStateInt)
    res = ReadU8CharValue(hAlarmStateChar, alarmStateInt)
    if res != 0 then
        print "\nUnable to read ALARM STATE", res
    endif
endfunc res

////
//// OnAlarmStateWritten()
////
sub OnAlarmStateWritten()

    // update whether or not to continue sampling
    res = ReadArmState(armState)
    res = ReadAlarmState(alarmState)
    UpdateIsSampling(armState, alarmState)

    // if alarm was just turned off, then recalibrate!
    //if alarmState == 0 then
    //    RecalibrateThresh()
    //endif

endsub

////
//// WriteAlarmState()
////
function WriteAlarmState(byVal alarmStateInt)
    // notifyAlarmState determines whether this also notifies
    res = WriteU8CharValue(hAlarmStateChar, alarmStateInt, notifyAlarmState)
    if res != 0 then
        print "\nUnable to write ALARM STATE", res
    else
        OnAlarmStateWritten()   // call OnWritten() handler
    endif

endfunc res

////
//// OnArmStateWritten()
////
sub OnArmStateWritten()

    // whether we are now armed or disarmed, we need to ensure
    // that alarm state is now OFF
    res = ReadAlarmState(alarmState)    // get current state
    if alarmState == 1 then
        alarmState = 0    // turn off alarm
        res = WriteAlarmState(alarmState)   // write/notify
    endif

    // update whether or not to continue sampling CDC data
    res = ReadArmState(armState)
    UpdateIsSampling(armState, alarmState)

endsub

////
//// WriteArmState()
////
function WriteArmState(byVal armStateInt)
    // notifyArmState determines whether this also notifies
    res = WriteU8CharValue(hArmStateChar, armStateInt, notifyArmState)
    if res != 0 then
        print "\nUnable to write ARM STATE", res
    else
        // call OnWritten() handler
        OnArmStateWritten()
    endif
endfunc res

////
//// ReadFromUart()
////
function ReadFromUart()

endFuncVal = 1
uartRes = 0
unknownCmd = 0

uartStrLen = uartRead(uartRxStr$)

if strcmp(uartRxStr$, termCmd$) == 0 then

    print "\nTrying to disconnect BLE..."
    if BleDisconnect(conn) == 0 then
        print "\nDisconnected."
    else
        print "\nUnable to disconnect. BLE may not have been connected..."
    endif
    print "\nEnding program execution."
    endFuncVal = 0

elseif strcmp(uartRxStr$, armCmd$) == 0 then
    uartRes = WriteArmState(1)
elseif strcmp(uartRxStr$, disarmCmd$) == 0 then
    uartRes = WriteArmState(0)
elseif strcmp(uartRxStr$, alarmOnCmd$) == 0 then
    uartRes = WriteAlarmState(1)
elseif strcmp(uartRxStr$, alarmOffCmd$) == 0 then
    uartRes = WriteAlarmState(0)
else
    // no recognized command
    unknownCmd = 1
endif

// if we ran a known command, print the result
if (uartRes == 0) && (endFuncVal == 1) && (unknownCmd == 0) then
    print "\nsuccess!"
elseif (uartRes == 1) && (endFuncVal == 1) && (unknownCmd == 0) then
    print "\nfailed.", res
endif

uartRxStr$ = ""     // reset the variable

endfunc endFuncVal

////
//// OnConnected()
////
sub OnConnected()

    // read arm/alarm state
    res = ReadArmState(armState)
    res = ReadAlarmState(alarmState)

    // see if we need to start sampling
    UpdateIsSampling(armState, alarmState)

endsub

////
//// HandleBleMsg()
///
function HandleBleMsg(byval msgId as integer, byval msgCtx as integer)
    print "\nmsgId: ", msgId
    select msgId
        case 0
            // received new connection! save connection handle
            conn = msgCtx
            OnConnected()
        case 1
            print "\nConnection lost."
            exitfunc 0  // we successfully disconnected!
        case else
            // do nothing special for now...
    endselect
endfunc 1

////
//// HandleCCCDWritten()
////
function HandleCCCDWritten(byVal charHandle, byVal cccdValue)

if charHandle == hArmStateChar then
    print "\nArm State CCCD written! Value: 0x", INTEGER.H'cccdValue
    armStateCCCD = cccdValue    // save arm state CCCD value
    notifyArmState = armStateCCCD & 0x01    // extract bit 0 (notify bit)

elseif charHandle == hAlarmStateChar then
    print "\nAlarm State CCCD written! Value: 0x", INTEGER.H'cccdValue
    alarmStateCCCD = cccdValue  // save alarm state CCCD value
    notifyAlarmState = alarmStateCCCD & 0x01    // extract bit 0 (notify bit)

endif

endfunc 1

////
//// HandleCharValWritten()
////
function HandleCharValWritten(byVal hChar, byVal offset, byVal length)

    if hChar == hAlarmStateChar then

        print "\nALARM STATE written by client"
        OnAlarmStateWritten()

    elseif hChar == hArmStateChar then

        print "\nARM STATE written by client"
        OnArmStateWritten()

    endif

endfunc 1

////
//// HandleUartRx()
////
function HandleUartRx()
    TimerStart(3,100,0)     // allow enough time for data to reach rx buffer
endfunc 1

////
//// DoSampleCapData()
////
function DoSampleCapData()

    // sample AD7746
    res = SampleAD7746Data(r0)

    res = ReadAlarmState(alarmState)
    res = ReadArmState(armState)

    // check for alarm condition (if not already alarming!)
    if alarmState == 0 then

        // if ARMED and IsAlarmCondition()
        if armState == 1 && IsAlarmCondition(r0) == 1 then
            // we have an alarm condition!
            res = WriteAlarmState(1)
        endif

    endif

    // todo: send capacitance values...

endfunc 1

////
//// main()
////

// set up event handlers
onevent EVBLE_ADV_TIMEOUT   call HandleBleAdvTimeout
onevent EVBLEMSG            call HandleBleMsg
onevent EVCHARVAL           call HandleCharValWritten
onevent EVCHARCCCD          call HandleCCCDWritten
onevent EVUARTRX            call HandleUartRx
onevent EVTMR0              call DoSampleCapData
onevent EVTMR3              call ReadFromUart

// init services and start advertising
StartBle()

// init/calibrate AD7746
SetupAD7746()

waitevent
